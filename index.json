[{"categories":["图神经网络入门"],"content":"卷积在深度学习中的应用很广泛，最开始接触深度学习的时候，一直认为卷积神经网络是专门用于图像特征提取的，实际上卷积神经网络最主要的优点在于其局部连接的特性，能有效减少网络参数，如果只关注图像的一个局部，对其进行卷积实际上就相当于通过了一个全连接层，而图像的每一个局部都共享了这个全连接；另一方面，对于图像、音频这种更加关注局部特征的数据，卷积神经网络这种局部的特性恰好与之对应，因此能够提升网络的表现；此外，卷积神经网络还具有平移不变性（这种平移不变性似乎不是在所有情况下都成立？），同样有助于特征提取。 在欧几里得数据上进行卷积通常是有意义的，例如对图像上局部的特征、句子中词与词之间的关系进行抽取。由于数据是在欧几里得平面整齐排列的，我们只需要用固定大小的卷积核进行卷积，但对于非欧数据，卷积的操作应该如何定义呢？ ","date":"2020-06-24","objectID":"/gnn-summary-2-gcn/:0:0","tags":["图神经网络","图卷积网络","机器学习","深度学习"],"title":"图神经网络总结(二) —— 图卷积网络","uri":"/gnn-summary-2-gcn/"},{"categories":["图神经网络入门"],"content":"2 谱域卷积 谱域卷积顾名思义是在图(graph)的谱域进行卷积，为此我们需要一个将图从顶点域(Vertex Domain)变换到谱域(Spectral Domain)的方法，在谱域进行卷积操作后再变换到顶点域。 ","date":"2020-06-24","objectID":"/gnn-summary-2-gcn/:1:0","tags":["图神经网络","图卷积网络","机器学习","深度学习"],"title":"图神经网络总结(二) —— 图卷积网络","uri":"/gnn-summary-2-gcn/"},{"categories":["图神经网络入门"],"content":"2.1 图的傅里叶变换 在数字信号处理领域，傅里叶变换被用来将信号从时域变换到频域分析，这里我们定义一个函数 $ f: V \\longrightarrow R $ (其中 $V$ 表示图上顶点的集合)来表示图信号 ，$f(i)$ 表示第 $i$ 个顶点的信号，同样的，我们也可以定义图上的傅里叶变换，将图信号从顶点域变换到谱域。 这里首先简单回顾一下传统的傅里叶变换： $$ \\mathscr{F}(\\omega)=\\int_{-\\infty}^\\infty f(t) e^{-i \\omega t}dt \\tag 1$$ 傅里叶变换的思想是将函数用一系列基( $ e^{-i \\omega t} $ )表示。 对于图信号，我们可以将其看成一个维度为 $N$ 的向量，即 $ f \\in R^N $ ，其中 $N$ 表示顶点集的大小，这里我们使用拉普拉斯矩阵的特征向量作为基( $N$ 个相互正交的 $N$ 维向量可以表示 $N$ 维空间中的任意向量)。 用 $\\lambda_l$ 和 $u_l$ 分别表示第 $l$ 个特征值和对应的特征向量， $\\hat{f}({\\lambda_l})$ 表示第 $l$ 个特征值对应的特征向量的系数，则有： $$ f(i) = \\sum^{N-1}_{l=0} \\hat{f}({\\lambda_l})u_l \\tag 2$$ 即： $$ f = U\\hat{f} \\tag 3$$ 因此我们可以得到图上的傅里叶变换： $$ \\hat{f} = U^Tf \\tag 4 $$ 这里先提出几点疑问放在后面讨论： 为什么要使用拉普拉斯矩阵的特征值作为基底（拉普拉斯算子之于傅里叶变换，图的结构） ","date":"2020-06-24","objectID":"/gnn-summary-2-gcn/:1:1","tags":["图神经网络","图卷积网络","机器学习","深度学习"],"title":"图神经网络总结(二) —— 图卷积网络","uri":"/gnn-summary-2-gcn/"},{"categories":["图神经网络入门"],"content":"2.2 谱域卷积 ","date":"2020-06-24","objectID":"/gnn-summary-2-gcn/:1:2","tags":["图神经网络","图卷积网络","机器学习","深度学习"],"title":"图神经网络总结(二) —— 图卷积网络","uri":"/gnn-summary-2-gcn/"},{"categories":["图神经网络入门"],"content":"参考 [1]. The Emerging Field of Signal Processing on Graphs: Extending High-Dimensional Data Analysis to Networks and Other Irregular Domains [2]. Graph Convolutions and Machine Learning [3]. Wiki: Laplacian Matrix ","date":"2020-06-24","objectID":"/gnn-summary-2-gcn/:2:0","tags":["图神经网络","图卷积网络","机器学习","深度学习"],"title":"图神经网络总结(二) —— 图卷积网络","uri":"/gnn-summary-2-gcn/"},{"categories":["图神经网络入门"],"content":"最近在看图神经网络的综述，数学功底太差看的云里雾里，记录一下学习过程中接触到的一些概念和自己的理解。 ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:0:0","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"0 简介 图像、语音、文本等都可以表示为欧几里得结构数据，传统的神经网络如CNN、RNN在处理这些欧几里得结构数据上取得了不错的效果。关于欧几里得数据和非欧几里得数据，引用论文 Geometric deep learning: going beyond Euclidean data 中的一段话： Many scientific fields study data with an underlying structure that is a non-Euclidean space. Some examples include social networks in computational social sciences, sensor networks in communications, functional networks in brain imaging, regulatory networks in genetics, and meshed surfaces in computer graphics. In many applications, such geometric data are large and complex (in the case of social networks, on the scale of billions), and are natural targets for machine learning techniques. In particular, we would like to use deep neural networks, which have recently proven to be powerful tools for a broad range of problems from computer vision, natural language processing, and audio analysis. However, these tools have been most successful on data with an underlying Euclidean or grid-like structure, and in cases where the invariances of these structures are built into networks used to model them. In image analysis applications, one can consider images as functions on the Euclidean space (plane), sampled on a grid. 原文把非欧几里得数据定义为数据潜在的结构是非欧空间的。以图像为例，我们可以看做一个欧氏平面（二维），在一个网格上采样得到图像的数据。（个人认为其实就是数据以什么方式表示的问题） 显然社交网络、知识图谱一类的图数据没办法直接用传统的神经网络处理，因此我们可以通过图嵌入(Graph Embedding)获得结点、结构等信息的向量表示，再应用到传统的机器学习方法上，而图神经网络相当于直接在图数据上进行学习，完成各种任务。图嵌入和图神经网络是密切相关也是非常相似的两个领域。 CNN: Extract Spatial Features ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:1:0","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"1 图神经网络 图神经网络(Graph Neural Networks, GNN)最早在A new model for learning in graph domains(2005年)提出，相关的工作还有The Graph Neural Network Model(2009年)，基本的思想是通过邻居结点间传播信息，获得图或结点的表示，这里介绍的图神经网络使用简单的前馈神经网络聚合邻居结点的信息。 ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:2:0","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"1.1 巴拿赫不动点定理 巴拿赫不动点定理又称压缩映射定理。 令 $(X, d)$ 为非空的完备度量空间，若映射 $f:X \\rightarrow X$ 满足 $\\forall x, y \\in X, d(x, y) \\le \\lambda d(T(x), T(y))$ ，则称 $f$ 是一个压缩映射。 巴拿赫不动点定理是指在完备度量空间中 $(X, d)$ ，设 $f:X \\rightarrow X$ 是一个压缩映射，则$f$在$X$中存在唯一不动点，对于 $\\forall x \\in X$ ,序列 $x, f(x), f(f(x)) …$ 收敛至 $f$ 的不动点。 ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:2:1","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"1.2 模型细节 GNN定义两个函数：$f$ 是局部转移函数(local transaction function)，用于整合自身结点、邻居结点以及边的信息： $$ h_v = f(x_v, x_{co[v]}, h_{ne[v]}, x_{ne[v]}) \\tag{1.1} $$ 其中 $h_v, x_v, x_{co[v]}, h_{ne[v]}, x_{ne[v]}$ 分别代表结点v的状态，结点v的特征，结点v的边的特征，邻居结点的状态，邻居结点的特征。 $g$ 是局部输出函数(local output function)： $$ o_v = g(x_v, h_v) \\tag{1.2} $$ $f$ 和 $g$都可以看做一个前馈神经网络，对于每个结点都是共享的，同时还要限制函数 $f$ 为压缩映射。 上面是每个结点状态和输出的函数，现在根据整个图整合成更紧凑的表达形式： $$ H = F(H, X) \\tag{1.3} $$ $$ O = G(H, X_v) \\tag{1.4} $$ $H, X_v$ 分别由所有结点的状态，所有结点的特征堆叠而成。 注： $H^{(t)} = F(H^{(t-1)}, X)$ ， $F$ 是关于 $H$ 的压缩映射。在计算所有结点的状态 $H^{(t-1)}$ 后，每个结点 $v$ 的邻居结点 $ne[v]$ 也接收到了其邻居结点的信息，因此不断迭代计算 $H^{(t)}, H^{(t+1)} …$可以接收到更远的结点的信息，不动点定理实际上保证了解的存在（不至于无穷无尽的迭代下去）。 最后是损失函数的部分。假设图中 $p$ 个结点拥有监督信息，则损失函数的形式为： $$ loss = \\sum_{i=1}^{p} (t_i - o_i) \\tag{1.5} $$ ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:2:2","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"1.3 训练过程 注意训练过程每个step都需要初始化每个结点的状态 $h_v$ 。 初始化H(0), 迭代计算$H^{(t)} = F(H^{(t-1)}, X)$直至稳定，计算loss 根据loss计算梯度，更新参数 重复1、2直至收敛 关于梯度的计算可以参考原论文 The Graph Neural Network Model ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:2:3","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"1.4 模型的局限 显然，基于不动点定理会使结点的状态比较相似，即Over Smooth，对于node-focused任务效果可能比较差 结点状态迭代的效率问题 部分边的信息无法被很好的建模，比如边的类型 ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:2:4","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"2 图神经网络的变种 ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:3:0","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"2.1 门控图神经网络(Gated Graph Neural Networks) GG-NN整体结构和GNN比较相似，最大的区别在于局部转移函数使用门控循环单元(GRU)代替，而GNN中局部转移函数是普通的前馈神经网络(FNN)，并且状态的转移不再依赖于不动点定理，而是迭代固定的次数 $T$ ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:3:1","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":["图神经网络入门"],"content":"参考 [1]. 从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型 (一) [2]. A Comprehensive Survey on Graph Neural Networks [3]. Geometric deep learning: going beyond Euclidean data [4]. Graph Neural Networks: A Review of Methods and Applications [5]. The Graph Neural Network Model [6]. Gated Graph Sequence Neural Networks ","date":"2020-06-23","objectID":"/gnn-summary-1-gnn/:4:0","tags":["图神经网络","机器学习","深度学习"],"title":"图神经网络总结(一) —— 图神经网络","uri":"/gnn-summary-1-gnn/"},{"categories":[],"content":"初识Beta分布 LDA-math-认识Beta/Dirichlet分布(1) 如何通俗的理解Beta分布 ","date":"2019-09-11","objectID":"/beta%E5%88%86%E5%B8%83%E5%92%8C%E5%85%B1%E8%BD%AD%E5%85%88%E9%AA%8C/:0:0","tags":["概率论","机器学习"],"title":"Beta分布和共轭先验","uri":"/beta%E5%88%86%E5%B8%83%E5%92%8C%E5%85%B1%E8%BD%AD%E5%85%88%E9%AA%8C/"},{"categories":[],"content":"题目链接 ","date":"2019-09-05","objectID":"/codeforces-round-582-div3/:0:0","tags":["Codeforces"],"title":"Codeforces Round 582 (Div 3)","uri":"/codeforces-round-582-div3/"},{"categories":[],"content":"A. Chips Moving 题目大意：对一个序列的每一个元素进行±1或±2的操作，其中±2的操作不计算代价，求最小代价使序列的每一个元素都相同。 思路： 求奇数个数和偶数个数的最小值。 代码： #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e #define MAXN 105 using namespace std; int a[MAXN]; int main() { int n; cin \u003e\u003e n; int num = 0; for (int i = 0; i \u003c n; i++) { int a; cin \u003e\u003e a; cout \u003c\u003c (a \u0026 1) \u003c\u003c \" \"; if ((a \u0026 1) == 0) ++num; } cout \u003c\u003c min(num, n - num) \u003c\u003c endl; return 0; } ","date":"2019-09-05","objectID":"/codeforces-round-582-div3/:0:1","tags":["Codeforces"],"title":"Codeforces Round 582 (Div 3)","uri":"/codeforces-round-582-div3/"},{"categories":[],"content":"B. Bad Prices 题目大意：给定一个序列，求满足下列条件的元素的个数：在其后面的元素中存在比它小的元素。 思路：逆序遍历序列，记录最小值，跟最小值比较并记录。 代码： #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e #define MAXN 150001 using namespace std; int a[MAXN]; int main() { int t; cin \u003e\u003e t; while (t--) { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) cin \u003e\u003e a[i]; int min = 1e6 + 1; int cnt = 0; for (int i = n - 1; i \u003e= 0; i--) if (a[i] \u003c= min) min = a[i]; else ++cnt; cout \u003c\u003c cnt \u003c\u003c endl; } return 0; } ","date":"2019-09-05","objectID":"/codeforces-round-582-div3/:0:2","tags":["Codeforces"],"title":"Codeforces Round 582 (Div 3)","uri":"/codeforces-round-582-div3/"},{"categories":[],"content":"C. Book Reading 题目大意：给定n和m，对于满足以下条件的所有整数i：i ≤ n 且 i mod m 余0，求所有i的个位数相加的结果。 思路：满足i mod m == 0的整数是m, 2m, 3m, …，不难发现当km的个位数为0时，(k+1)m, (k+2)m, (k+3)m,…的个位数与m, 2m, 3m, …相等，所以对于每个m只需要找出这个最小的周期就可以了，由于只需要考虑个位数，可以先把0~9的周期计算一下，例如2的周期是5,3的周期是10，另外再算一下周期内个位数之和。最后求出周期数和处理一下余数就可以了。（代码写复杂了） 代码： #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e using namespace std; long long table[] = {1, 10, 5, 10, 5, 2, 5, 10, 5, 10}; long long table_sum[10]; int init() { for (int i = 1; i \u003c 10; i++) for (int j = 1; j \u003c table[i]; j++) table_sum[i] += (j * i) % 10; // for (int i = 0; i \u003c 9; i++) // cout \u003c\u003c table_sum[i] \u003c\u003c \" \"; // cout \u003c\u003c endl; } int main() { int t; init(); cin \u003e\u003e t; while (t--) { long long n, m; cin \u003e\u003e n \u003e\u003e m; if (n \u003c m) { cout \u003c\u003c 0 \u003c\u003c endl; continue; } int last = m % 10; if (last == 0) { cout \u003c\u003c 0 \u003c\u003c endl; continue; } long long num = table[last] * m; long long ret = n / num * table_sum[last]; long long mod = n % num; for (long long i = m; i \u003c= mod; i += m) ret += i % 10; cout \u003c\u003c ret \u003c\u003c endl; } return 0; } ","date":"2019-09-05","objectID":"/codeforces-round-582-div3/:0:3","tags":["Codeforces"],"title":"Codeforces Round 582 (Div 3)","uri":"/codeforces-round-582-div3/"},{"categories":[],"content":"D. Equalizing by Division 题目大意：对于元素ai,进行如下操作ai:=⌊ai/2⌋(向下取整)，对于每个元素这种操作可以进行任意次数，问最少需要多少次这样的操作可以让序列中有k个相等的元素。 思路：感觉挺有意思的一道题，首先对于元素ai，对2×ai和2×ai+1进行上述操作都可以得到2×ai。可以看成一个二叉树，对于所有结点x，求出以结点x为根的子树中高度最靠近x的k个结点（贪心的思想，实际上子树中子结点跟根结点的高度差就是改子结点变换为根结点所需操作的次数）。找出拥有最小值的结点即可。 代码： #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cmath.h\u003e #define MAXN (int)2e5 + 1 #define MAXD 18 #define INF 0x3f3f3f3f using namespace std; int a[MAXN]; int num[MAXN]; int ret = 0; int dl, dr; int cal_range(int root, int root_depth, int depth) { int l = root \u003c\u003c (depth - root_depth); int r = l + (1 \u003c\u003c (depth - root_depth)) - 1; l = min(MAXN, l); r = min(MAXN - 1, r); return (num[r] - num[l - 1]); } int find_ret(int i, int depth, int k) { int root_depth = depth; ++depth; k -= a[i]; int ret = 0; while (depth \u003c= MAXD \u0026\u0026 k \u003e 0) { int num = cal_range(i, root_depth, depth); ret += (depth - root_depth) * (num \u003e k ? k : num); k -= num; ++depth; } if (k \u003e 0) return INF; return ret; } void solve(int k) { int ret = INF; for (int i = 1; i \u003c= MAXN; i++) { int depth = (int)log2(i) + 1; ret = min(ret, find_ret(i, depth, k)); } cout \u003c\u003c ret \u003c\u003c endl; } int main() { int n, k; fill(a, a + MAXN, 0); cin \u003e\u003e n \u003e\u003e k; for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x; ++a[x]; } num[0] = 0; for (int i = 1; i \u003c= MAXN; i++) num[i] = num[i - 1] + a[i]; solve(k); return 0; } ","date":"2019-09-05","objectID":"/codeforces-round-582-div3/:0:4","tags":["Codeforces"],"title":"Codeforces Round 582 (Div 3)","uri":"/codeforces-round-582-div3/"},{"categories":[],"content":"E. Two Small Strings 题目大意：给定两个长度为2的子串，每个子串由’a’,‘b’,‘c’组成，可以重复，给定n，要求构造一个字符串由n个‘a’,n个’b’,n个’c’组成，并且不含给定的子串。 思路：水过去的，没有思路。。。 代码： #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cmath.h\u003e#include \u003cstring\u003e #define MAXN (int)1e5 + 1 #define INF 0x3f3f3f3f using namespace std; int main() { int n; cin \u003e\u003e n; string sub[2]; for (int i = 0; i \u003c 2; i++) cin \u003e\u003e sub[i]; // n = 2; // string sub_list[9]; string s = \"abc\"; // int index = 0; // for (int i = 0; i \u003c 3; i++) // for (int j = 0; j \u003c 3; j++) // { // string tmp = string(); // tmp += s[i]; // tmp += s[j]; // sub_list[index++] = tmp; // } // for (int i = 0; i \u003c 9; i++) // for (int j = i + 1; j \u003c 9; j++) // { // string sub[2]; // sub[0] = sub_list[i]; // sub[1] = sub_list[j]; // bool find = false; // s = \"abc\"; // do // { // string tmp = string(s); // if (n \u003e 1) // tmp = tmp + s[0]; // bool ok = true; // for (int i = 0; i \u003c 2; i++) // { // if (tmp.find(sub[i]) != string::npos) // { // ok = false; // break; // } // } // if (ok) // { // find = true; // break; // } // } while (next_permutation(s.begin(), s.end())); // if (find) // { // string sub = string(s); // s = \"\"; // for (int i = 0; i \u003c n; i++) // s += sub; // // cout \u003c\u003c \"YES\" \u003c\u003c endl; // // cout \u003c\u003c s \u003c\u003c endl; // } // else // { // cout \u003c\u003c \"NO\" \u003c\u003c endl; // cout \u003c\u003c sub[0] \u003c\u003c endl; // cout \u003c\u003c sub[1] \u003c\u003c endl; // } // } bool find = false; do { string tmp = string(s); if (n \u003e 1) tmp = tmp + s[0]; bool ok = true; for (int i = 0; i \u003c 2; i++) { if (tmp.find(sub[i]) != string::npos) { ok = false; break; } } if (ok) { find = true; break; } } while (next_permutation(s.begin(), s.end())); if (find) { string sub = string(s); s = \"\"; for (int i = 0; i \u003c n; i++) s += sub; cout \u003c\u003c \"YES\" \u003c\u003c endl; cout \u003c\u003c s \u003c\u003c endl; } else { string s = \"abc\"; bool find = false; do { string tmp = string(s); bool ok = true; for (int i = 0; i \u003c 2; i++) { if (tmp.find(sub[i]) != string::npos) { ok = false; break; } } if (ok) { find = true; break; } } while (next_permutation(s.begin(), s.end())); if (find) { string sub = string(s); s = \"\"; for (int j = 0; j \u003c 3; j++) for (int i = 0; i \u003c n; i++) s += sub[j]; cout \u003c\u003c \"YES\" \u003c\u003c endl; cout \u003c\u003c s \u003c\u003c endl; } else cout \u003c\u003c \"NO\" \u003c\u003c endl; } return 0; } ","date":"2019-09-05","objectID":"/codeforces-round-582-div3/:0:5","tags":["Codeforces"],"title":"Codeforces Round 582 (Div 3)","uri":"/codeforces-round-582-div3/"},{"categories":[],"content":"先随便选一个接口分析一下，就选评论接口吧。 ","date":"2019-06-02","objectID":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/:0:0","tags":["Python","爬虫"],"title":"网易云音乐网页API分析","uri":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/"},{"categories":[],"content":"1.获取评论 进入Chrome开发者模式可以看到 这个就是获取评论的接口，请求方式是POST，请求体有两个参数params和encSecKey，在请求的Initiator可以看到发出请求的代码在core_xxxx.js这个文件，代码肯定经过混淆，先下载到本地格式化一下。在js文件中搜索encSecKey，找到生成参数的相关代码段，可以看到参数由asrsea这个函数生成。 var bYc0x = window.asrsea(JSON.stringify(i8a), bkY9P([\"流泪\", \"强\"]), bkY9P(VM5R.md), bkY9P([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); e8e.data = k8c.cz9q({ params: bYc0x.encText, encSecKey: bYc0x.encSecKey }) 继续在js文件中搜索这个函数，可以看到生成参数的相关函数： function a(a) { var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; for (d = 0; a \u003e d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c } //生成encText，即params function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b), //密钥 d = CryptoJS.enc.Utf8.parse(\"0102030405060708\"), //初始化向量 e = CryptoJS.enc.Utf8.parse(a), //数据 f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } //生成encSecKey function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b, \"\", c), e = encryptedString(d, a) } //spider 加密函数 function d(d, e, f, g) { var h = {}, i = a(16); //随机生成一个由a~z,A~Z,0~9组成的长度为a的字符串（AES密钥） return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } function e(a, b, d, e) { var f = {}; return f.encText = c(a + e, b, d), f } window.asrsea = d, window.ecnonasr = e params的生成过程比较简单，在函数d中可以看到params由两次调用函数b得到：函数b是AES加密的过程，参数a是要加密的数据，参数b是密钥，params经过两次AES加密得到，通过调试可以看到第一次加密： h.encText = b(d, g) 参数g是固定的： 0CoJUm6Qyw8W8jud 而参数d则是请求参数构成的json字符串，在上面的请求中是： {“rid”:“R_SO_4_1361988914”,“offset”:“0”,“total”:“true”,“limit”:“20”,“csrf_token”:\"\"} offset代表获取的第一条评论的偏移量，limit是获取的评论数。 第二次加密是使用随机生成的密钥（长度为16）加密第一次加密生成的数据。为了方便测试，在原网页获取随机生成的某密钥以及用这个密钥加密得到的params和encSecKey： key: 6lauqIqaJelwkFKM params: 1NGJ2rghqo1ToCy5r27rEDqRCNEZxxKk2BvmOQoud6GTNfPZKGRJVFmqfJWeAXYQi4V/++6HKpDjFDfB+TZZ+cmDQF2ywgL9w5Ow8r+mtLG95D7rfUfRkT7GiTn4KMCt+mIM9dtgtIoKXSZ77407F/ZI/GCfslievQ0IfnBAR8SoKQmz8XaQgC1Lxo93VxQ4 encSecKey: 2d1a892a0d7b3101eb00936c4915b2541bc378b58a5ccf6ab3ca939da1fd1fcee7b7456feef0a0d9115c1b5aad8aa64674df8249597e9e74ab66cb5fa84a624f174ed59e786fef748528fff098fa749c11aa06d7d86b7a41d917277efb3f14f8b974ddb2cb5df638ec36d3de8c2f02335cb1990b150a8deafc186c2007dea21c 其中AES加密的填充方式是pkcs#7padding，块大小是16 Bytes，加密后的数据默认使用base64编码，根据pkcs#7padding的规则，需要在数据后面添加(16 - n%16)个byte（无论n的长度是否是16的整数倍），且byte的值也为(16 - n%16)。 from Crypto.Cipher import AES import base64 def pkcs7_padding(data): n = 16 - len(data) % 16 data += (chr(n) * n).encode() return data key = '0CoJUm6Qyw8W8jud'.encode('utf-8') mode = AES.MODE_CBC iv = '0102030405060708'.encode('utf-8') aes = AES.new(key, mode, iv) data = '{\"rid\":\"R_SO_4_1361988914\",\"offset\":\"0\",\"total\":\"true\",\"limit\":\"20\",\"csrf_token\":\"\"}'.encode('utf-8') data = pkcs7_padding(data) endata = aes.encrypt(data) endata = base64.b64encode(endata) key = '6lauqIqaJelwkFKM'.encode('utf-8') aes = AES.new(key, mode, iv) data = pkcs7_padding(endata) endata = aes.encrypt(data) endata = base64.b64encode(endata) print(endata) 得到的数据与请求中的一致。 再分析一下encSecKey的生成过程，在函数d中可以看到encSecKey由函数c生成：函数c将随机生成的密钥（就是上面生成params时AES加密的密钥）经过RSA加密得到encSecKey。 关于RSA加密的过程，源代码在这里可以看到:http://www.ohdave.com/rsa RSAKeyPair包括encryptionExponent,decryptionExponent,modulus（分别对应代码中RSAKeyPair函数的三个参数，根据RSA加密的过程：公钥包含两个大整数，n和e，假设要加密的数据是m，则加密后的数据$c ≡ m^e \\ (mod \\ n)$,这里的e就是encryptionExponent，n就是modulus。 e和n两个数应该是固定的（公钥应该不会频繁更换吧），在RSAKeyPair函数打断点得到e和n的值分别是： 010001 和 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 一开始我尝试直接对数据进行加密： import rsa import binascii rsa_n = int(\"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\", 16) rsa_e = int(\"010001\", 16) key = rsa","date":"2019-06-02","objectID":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/:0:1","tags":["Python","爬虫"],"title":"网易云音乐网页API分析","uri":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/"},{"categories":[],"content":"2.获取歌词 通过上面的分析已经得到参数加密的方法，所以我们只需要知道请求这个接口都有什么参数就可以了。 example: {“id”:“1361988914”,“lv”:-1,“tv”:-1,“csrf_token”:\"\"} lv,tv这几个参数暂时不知道作用是什么，有兴趣的可以自己研究研究。 url: https://music.163.com/weapi/song/lyric method: POST query: csrf_token params: ID(int), lv(int), lv(int), csrf_token(string) ","date":"2019-06-02","objectID":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/:0:2","tags":["Python","爬虫"],"title":"网易云音乐网页API分析","uri":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/"},{"categories":[],"content":"3.获取播放列表 在网页打开播放列表得到的列表详情是在后端处理过直接返回给浏览器的，没有暴露接口，但是通过官方提供的iframe插件可以得到一个接口，例如这个歌单：https://music.163.com/outchain/player?type=0\u0026id=2821194580\u0026auto=1\u0026height=430 ，加密方式跟上文一样： example: {“id”:“2821194580”,“ids”:\"[\"2821194580\"]”,“limit”:10000,“offset”:0,“csrf_token”:\"\"} id参数是必须的，ids参数的作用暂时不知道是什么。但是这个接口目前好像没办法正常使用，limit和offset设置是无效的，一次最多获取1000条歌曲数据，而且也无法获取订阅状态，还需要再研究研究。 url: https://music.163.com/weapi/playlist/detail method: POST params: id(int), ids(array), limit(int), offset(int), csrf_token(string) ","date":"2019-06-02","objectID":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/:0:3","tags":["Python","爬虫"],"title":"网易云音乐网页API分析","uri":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/"},{"categories":[],"content":"4.搜索 4.1 推荐 example： {“s”:“陈奕迅”,“limit”:“8”,“csrf_token”:\"\"} url: https://music.163.com/weapi/cloudsearch/get/web method: POST query: csrf_token params: s(string), limit(int), csrf_token(string) 4.2 各种搜索 example: {“hlpretag”:“\u003cspan class=\"s-fc7\"\u003e”,“hlposttag”:“”,“s”:“陈奕迅”,“type”:“1”,“offset”:“0”,“total”:“true”,“limit”:“30”,“csrf_token”:\"\"} 前面hlpretag和hlposttag暂时不知道作用是什么，可以不加进去，如果要加进去加密的时候记得要把转义符号也当成字符串的一部分，在python中可以在字符串前面加r表示raw string。 其中type是搜索的类型： 1 歌曲 10 专辑 100 歌手 1000 歌单 1002 用户 1006 歌词 1009 电台 1014 视频 其他的参数比较明显就不细说了。 url: https://music.163.com/weapi/cloudsearch/get/web method: POST query: csrf_token params: s(string), type(int), offset(int), total(int), limit(int), csrf_token(string) ","date":"2019-06-02","objectID":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/:0:4","tags":["Python","爬虫"],"title":"网易云音乐网页API分析","uri":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/"},{"categories":[],"content":"5.用户Token 先分析怎么通过手机登录获取token。 这个稍微复杂点，因为传递给服务器的参数中password是经过加密的，只要找出加密的方法就可以了。首先还是找到跟加密password相关的函数，这个断点多花点时间是可以找出来的。 在pt_frame_index.js这个文件里面发现如下代码： var i9b = { countrycode: gX3x.countrycode, phone:gX3x.mobile, password:k9b.lB4F(gX3x.password), rememberLogin:this.RU4Y.checked } 其中lB4F这个函数就是加密password的函数，接着找到： p.lB4F = function(i9b) { return XC6w(LI2x(xC8u(i9b, !0), i9b.length * nA5F), !0) }; var nA5F = 8; var xC8u = function() { var GB0x = function(i) { return i % 32 }, Gx0x = function(i) { return 32 - nA5F - i % 32 }; return function(cQ2x, Gw0x) { var Xr6l = [], lI4M = (1 \u003c\u003c nA5F) - 1, mE5J = Gw0x ? GB0x: Gx0x; for (var i = 0, l = cQ2x.length * nA5F; i \u003c l; i += nA5F) Xr6l[i \u003e\u003e 5] |= (cQ2x.charCodeAt(i / nA5F) \u0026 lI4M) \u003c\u003c mE5J(i); return Xr6l } } (); var LI2x = function(x, y) { x[y \u003e\u003e 5] |= 128 \u003c\u003c y % 32; x[(y + 64 \u003e\u003e\u003e 9 \u003c\u003c 4) + 14] = y; var a = 1732584193, b = -271733879, c = -1732584194, d = 271733878; for (var i = 0, l = x.length, bFW5b, bFX5c, bGc5h, bGd5i; i \u003c l; i += 16) { bFW5b = a; bFX5c = b; bGc5h = c; bGd5i = d; a = qb5g(a, b, c, d, x[i + 0], 7, -680876936); d = qb5g(d, a, b, c, x[i + 1], 12, -389564586); c = qb5g(c, d, a, b, x[i + 2], 17, 606105819); b = qb5g(b, c, d, a, x[i + 3], 22, -1044525330); a = qb5g(a, b, c, d, x[i + 4], 7, -176418897); d = qb5g(d, a, b, c, x[i + 5], 12, 1200080426); c = qb5g(c, d, a, b, x[i + 6], 17, -1473231341); b = qb5g(b, c, d, a, x[i + 7], 22, -45705983); a = qb5g(a, b, c, d, x[i + 8], 7, 1770035416); d = qb5g(d, a, b, c, x[i + 9], 12, -1958414417); c = qb5g(c, d, a, b, x[i + 10], 17, -42063); b = qb5g(b, c, d, a, x[i + 11], 22, -1990404162); a = qb5g(a, b, c, d, x[i + 12], 7, 1804603682); d = qb5g(d, a, b, c, x[i + 13], 12, -40341101); c = qb5g(c, d, a, b, x[i + 14], 17, -1502002290); b = qb5g(b, c, d, a, x[i + 15], 22, 1236535329); a = pT5Y(a, b, c, d, x[i + 1], 5, -165796510); d = pT5Y(d, a, b, c, x[i + 6], 9, -1069501632); c = pT5Y(c, d, a, b, x[i + 11], 14, 643717713); b = pT5Y(b, c, d, a, x[i + 0], 20, -373897302); a = pT5Y(a, b, c, d, x[i + 5], 5, -701558691); d = pT5Y(d, a, b, c, x[i + 10], 9, 38016083); c = pT5Y(c, d, a, b, x[i + 15], 14, -660478335); b = pT5Y(b, c, d, a, x[i + 4], 20, -405537848); a = pT5Y(a, b, c, d, x[i + 9], 5, 568446438); d = pT5Y(d, a, b, c, x[i + 14], 9, -1019803690); c = pT5Y(c, d, a, b, x[i + 3], 14, -187363961); b = pT5Y(b, c, d, a, x[i + 8], 20, 1163531501); a = pT5Y(a, b, c, d, x[i + 13], 5, -1444681467); d = pT5Y(d, a, b, c, x[i + 2], 9, -51403784); c = pT5Y(c, d, a, b, x[i + 7], 14, 1735328473); b = pT5Y(b, c, d, a, x[i + 12], 20, -1926607734); a = pQ5V(a, b, c, d, x[i + 5], 4, -378558); d = pQ5V(d, a, b, c, x[i + 8], 11, -2022574463); c = pQ5V(c, d, a, b, x[i + 11], 16, 1839030562); b = pQ5V(b, c, d, a, x[i + 14], 23, -35309556); a = pQ5V(a, b, c, d, x[i + 1], 4, -1530992060); d = pQ5V(d, a, b, c, x[i + 4], 11, 1272893353); c = pQ5V(c, d, a, b, x[i + 7], 16, -155497632); b = pQ5V(b, c, d, a, x[i + 10], 23, -1094730640); a = pQ5V(a, b, c, d, x[i + 13], 4, 681279174); d = pQ5V(d, a, b, c, x[i + 0], 11, -358537222); c = pQ5V(c, d, a, b, x[i + 3], 16, -722521979); b = pQ5V(b, c, d, a, x[i + 6], 23, 76029189); a = pQ5V(a, b, c, d, x[i + 9], 4, -640364487); d = pQ5V(d, a, b, c, x[i + 12], 11, -421815835); c = pQ5V(c, d, a, b, x[i + 15], 16, 530742520); b = pQ5V(b, c, d, a, x[i + 2], 23, -995338651); a = pA5F(a, b, c, d, x[i + 0], 6, -198630844); d = pA5F(d, a, b, c, x[i + 7], 10, 1126891415); c = pA5F(c, d, a, b, x[i + 14], 15, -1416354905); b = pA5F(b, c, d, a, x[i + 5], 21, -57434055); a = pA5F(a, b, c, d, x[i + 12], 6, 1700485571); d = pA5F(d, a, b, c, x[i + 3], 10, -1894986606); c = pA5F(c, d, a, b, x[i + 10], 15, -1051523); b = pA5F(b, c, d, a, x[i + 1], 21, -2054922799); a = pA5F(a, b, c, d, x[i + 8], 6, 1873313359); d = pA5F(d, a, b, c, x[i + 15], 10, -30611744); c = pA5F(c, d, a, b, x[i + 6], 15, -1560198380); b = pA5F(b, c, d, a, x[i + 13], 21, 1309151649); a = pA5F(a, b, c, d, x[i + 4], 6, -145523070); d = pA5F(d, a, b, c, x[i + 11], 10, ","date":"2019-06-02","objectID":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/:0:5","tags":["Python","爬虫"],"title":"网易云音乐网页API分析","uri":"/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%BD%91%E9%A1%B5api%E5%88%86%E6%9E%90/"},{"categories":[],"content":" 2019.06.01更新 新增几个命令： /reload 重新加载功能异常的评论区 /recover 恢复被误删的评论区 /enable 手动开启评论区 增加的内容放在dev分支 计划更新： 黑名单功能 评论删除 设置非频道订阅者的评论权限 2019.05.28更新 肝了快4天终于把第一个版本肝完了 Github项目地址 前几天有人问我Telegram上的频道评论机器人有没有楼中楼和通知功能，找了一下好像没找到，突然感兴趣自己写一个，看了一下Telegram提供的Bot API，觉得应该是能实现。 用Go语言写是因为只带了笔记本回家，笔记本上只装了Go的开发环境，懒得去折腾，就干脆用Go写吧。 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:0:0","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"（一）申请机器人 给 @BotFather 发送 /newbot 指令，按照指示完成机器人创建，创建成功会得到一个token，是调用Telegram API必备的，如果没有保存可以发送 /token 指令重新生成一个token，也可以发送 /revoke 指令撤销token。 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:1:0","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"（二）环境配置 关于Go开发环境的配置不再赘述，网上有很多教程。关于Telegram Bot API，官方提供了使用http(s)协议的API，这里为了方便使用Go语言封装好的API。 API地址 API文档 在项目目录输入 go get -u github.com/go-telegram-bot-api/telegram-bot-api 或 go get gopkg.in/telegram-bot-api.v4 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:2:0","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"（三）Bot API 建议在使用前先看看官方的API文档。 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:3:0","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"1 Keyboards 我们经常可以在一些频道看到消息下方显示了按钮，这种按钮是通过在消息添加InlineKeyboards实现的，InlineKeyboards的按钮有callback(发送数据给bot)、url(跳转到链接)、switch to inline(在当前会话或选择一个新的会话输入inline query)这三种。 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:3:1","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"2 Update Bot只有在被添加到群组、频道或者私人对话中才能接收消息。一个Update可以看做机器人接收的一个消息，当我们发送消息在群组、频道或发送消息给机器人、点击按钮产生的回调等都是一个Update。 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:3:2","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"3 getUpdates 官方提供两种方式获取更新，一种方式是使用长轮询向Telegram服务器拉取更新(返回一个Update数组)，使用这种方式需要不断的更新offset的值，offset代表获取的Update数组里第一个Update的update_id，如果offset设置不正确会获取到已经获取过的更新，另一种方式是通过设置Webhook指定一个接收Update的服务器，有新的Update时，Telegram服务器会自动将数据用POST的方式发送到指定的服务器，使用这种方式不会接收到已经接收过的更新，并且可以实时接收到更新，前提是指定的服务器需要有公网ip和https，本地开发我们可以借助ngrok把本地地址映射到公网地址上。这里采用第二种方式。 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:3:3","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"（四）实现 ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:4:0","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"1 设置Webhook并获取更新 设置Bot Token和Webhook token := \"你的bot token\" bot, err := tgbotapi.NewBotAPI(token) if err != nil { panic(err) } bot.Debug = true //地址路径加上token可以用于验证消息推送者的身份 ret, err := bot.SetWebhook(tgbotapi.NewWebhook(\"https://公网地址/\" + bot.Token)) if err != nil { panic(err) } log.Println(ret) 接收更新 //返回一个 chan Update updates := h.bot.ListenForWebhook(\"/\" + h.bot.Token) go http.ListenAndServe(\"0.0.0.0:80\", nil) for update := range updates { //处理Update } ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:4:1","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"2 给频道消息加上操作按钮 首先判断消息来源是不是频道 if update.ChannelPost != nil { handleChannelMessage(update.ChannelPost) } 先转发原post，然后编辑转发消息，给转发消息加上键盘。 点击按钮时打开机器人对话框，把ChatID和消息的MessageID（ChatID和MessageID共同标识一条消息）作为参数传递给机器人（用Deep-linking实现）。 点击按钮 config := \u0026tgbotapi.MessageConfig{ BaseChat: tgbotapi.BaseChat{ ChatID: message.Chat.ID, ReplyToMessageID: message.MessageID, DisableNotification: true, }, Text: \"暂无评论\", } msg, err := h.bot.Send(config) if err == nil { post := \u0026models.Post{ MessageID: message.MessageID, ChatID:message.Chat.ID, AreaID: msg.MessageID, } //生成Deep-linking参数 param, err := utils.EncodeParam(post) if err != nil { log.Println(err) return } url := \"http://t.me/comment_it_bot?start=\" + param keyboard := utils.NewInlineKeyboardMarkup( tgbotapi.NewInlineKeyboardRow( tgbotapi.InlineKeyboardButton{ Text: \"查看详情️\", URL: \u0026url, })) _, err = h.bot.Send(tgbotapi.NewEditMessageReplyMarkup(msg.Chat.ID, msg.MessageID, keyboard)) h.commentRepo.InsertPost(post) } ","date":"2019-05-24","objectID":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/:4:2","tags":["Go语言"],"title":"Go语言编写Telegram评论机器人","uri":"/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99telegram%E8%AF%84%E8%AE%BA%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"categories":[],"content":"Codeforces 1153C(Round 551 Div2) Serval and Parenthesis Sequence 题目链接：http://codeforces.com/problemset/problem/1153/C 题目大意：给定一个由’(’, ‘)’, ‘?‘组成的字符串s，要求填充’?‘为’(‘或’)‘使得从s[0]开始的任意长度的前缀不是一个正确的序列（空串和s本身不算前缀），而s是一个正确的序列。 思路：要满足任意前缀不是正确的序列，第一个括号要跟最后一个括号匹配，也就是填充’?‘使s[1]~s[n-2]是一个正确的序列。记’(‘对平衡程度的贡献是+1，')‘为-1，一个序列只要满足任意前缀的平衡程度始终大于或等于0且序列本身的平衡程度为0，那么这个序列就是正确的。为了满足条件，我们可以使前面的’(‘尽可能的多。 代码比较简单就不贴了~ ","date":"2019-05-17","objectID":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/:0:1","tags":["Codeforces"],"title":"几道题目","uri":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/"},{"categories":[],"content":"Codeforces 1151C(Round 553 Div2) Problem for Nazar 题目链接：http://codeforces.com/problemset/problem/1151/C 题目大意：将从1开始的整数按照{1},{2,4},{3,5,7,9},…的顺序排列（第n个序列的长度是2n，n从0开始，奇偶奇偶奇偶…）。现在给定l和r(1≤l≤r≤1018) ，要求第l个数到第r个数之和，结果对1000000007取余。 思路：简单的数学题，没啥好说的。。。就是代码写起来有点麻烦。规律比较好找，分析一下可以求出$l$到$r$上奇数的个数和偶数的个数，直接用求和公式就行了。 代码：代码写得素质极差就不贴了。。。 ","date":"2019-05-17","objectID":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/:0:2","tags":["Codeforces"],"title":"几道题目","uri":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/"},{"categories":[],"content":"Codeforces 1151D(Round 553 Div2) Stas and the Queue at the Buffet 题目链接：http://codeforces.com/problemset/problem/1151/D 题目大意：有n个学生，对于第i个学生有两个属性：ai和bi。假设第i个学生排在第j个位置，他的不满程度是ai * 站在他左边的人数 + bi * 站在他右边的人数。现在要求安排每个学生的位置使总的不满程度最低。 思路：还是数学题，设第i个学生的位置是pi，则总的不满程度：$$s = \\sum_{i=0}^{n-1} a_i * p_i + b_i * (n-1-p_j) = \\sum_{i=0}^{n-1} (a_i - b_i) * p_i + b_i * (n-1)$$ s只跟(ai - bi) * pi相关，所以直接把(ai - bi)按从大到小的顺序排列就行了。 代码： #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003calgorithm\u003e#include \u003cstring.h\u003e#include \u003cmath.h\u003e #define MAXN 100005 using namespace std; //long long typedef struct { int a, b; int sub; }S; S s[MAXN]; bool cmp(S a, S b) { return a.sub \u003e b.sub; } int main() { int n; cin\u003e\u003en; for(int i = 0; i \u003c n; i++) { cin\u003e\u003es[i].a\u003e\u003es[i].b; s[i].sub = s[i].a - s[i].b; } sort(s, s + n, cmp); long long ret = 0; for(int i = 0; i \u003c n; i++) ret += (long long)s[i].a * i + (long long)s[i].b * (n - i - 1); cout\u003c\u003cret\u003c\u003cendl; return 0; } ","date":"2019-05-17","objectID":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/:0:3","tags":["Codeforces"],"title":"几道题目","uri":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/"},{"categories":[],"content":"Codeforces 1151E(Round 553 #Div2) Number of Components 题目链接：http://codeforces.com/problemset/problem/1151/E 题目大意：一个无环无向连通图有n个顶点($1\\leq{n}\\leq10^5$)，第i个顶点与第i+1个顶点相连,每个顶点都有对应的属性值。给定$l$和$r$，用$f(l,r)$表示删去属性值不在$l$到$r$的范围内的顶点后连通块的个数。要求计算$\\sum_{l=1}^n\\sum_{r=l}^n f(l,r)$的值。 ","date":"2019-05-17","objectID":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/:0:4","tags":["Codeforces"],"title":"几道题目","uri":"/%E5%87%A0%E9%81%93%E9%A2%98%E7%9B%AE/"},{"categories":[],"content":"先填个坑~ 上次做div3的时候没有做出来，感觉好像不是一道特别难的题目 题目链接：http://codeforces.com/problemset/problem/1154/F 题目大意： 有n把铲子，记第i把的价格为ci。同时给你m个special offers，对于优惠j，用(xj, yj)表示选择xj把铲子购买，其中价格最便宜的yj把铲子免费，每个优惠可以被使用任意次数（包括0），但是每次购买只能使用一个优惠或不使用优惠。现在要求你买k把铲子（可以分多次购买），问最小花费。 输入： 第一行输入三个整数n,m 和 k (1≤n,m≤2⋅105,1≤k≤min(n,2000)) —— 分别表示有n把铲子、m个优惠、需要购买k把铲子。 第二行输入n个整数a1,a2,…,an (1≤ai≤2⋅105)，表示n把铲子的价格。 接下来的m行每行输入两个整数xj和yj (1≤yj≤xj≤n) 表示第j个优惠。 输出： 一个整数，表示购买k把铲子的最小花费。 思路： 总体思路是贪心+动态规划，首先可以确定在最小花费的情况下，购买的k把铲子一定是n把铲子中价格最便宜的k把，可以这么理解：任意取k把铲子，先按价格排序，假设通过使用优惠，购买其中的第i1,i2,…,im (m \u003c= k)把铲子达到最小花费c，那么对于k把价格最便宜的铲子，通过使用优惠购买其中的第i1,i2,…,im (m \u003c= k)把铲子，花费必定小于等于c。 这样问题就变成对于k把铲子，怎么组合使用优惠可以使花费最小。首先明确一个优惠怎么使用是最优的：当免费的价格最大时最优，所以我们可以把k把铲子按价格从高到低排序。用dp[i]表示购买前i把铲子的最小花费，显然dp[i]可以从dp[i - 1]（不使用优惠）或dp[i - offer[j].x]得到（使用优惠j），状态转移方程就不写了。对于每个i枚举所有的优惠，时间复杂度是O(k*m)。 代码： #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003calgorithm\u003e#include \u003cstring.h\u003e #define MAXN 200005 #define MAXM 200005 #define MAXK 2001 using namespace std; typedef struct { int x, y; }Offer; int a[MAXN]; Offer o[MAXM]; long long dp[MAXN]; long long sum[MAXN]; bool cmp(int a, int b) { return a \u003e b; } int main() { int n, m, k; cin\u003e\u003en\u003e\u003em\u003e\u003ek; for(int i = 1; i \u003c= n; i++) cin\u003e\u003ea[i]; for(int i = 0; i \u003c m; i++) cin\u003e\u003eo[i].x\u003e\u003eo[i].y; sort(a + 1, a + 1 + n, cmp); sum[n - k] = 0; for(int i = n - k + 1; i \u003c= n; i++) { sum[i] = sum[i - 1] + a[i]; dp[i] = sum[i]; } dp[n - k] = 0; for(int i = n - k; i \u003c= n; i++) { for(int j = 0; j \u003c m; j++) { if(i + o[j].x \u003c= n) dp[i + o[j].x] = min(dp[i + o[j].x], dp[i] + sum[i + o[j].x - o[j].y] - sum[i]); else dp[n] = min(dp[n], dp[i] + sum[n] - sum[i]); } } cout\u003c\u003cdp[n]\u003c\u003cendl; return 0; } 跑了一下1965ms，有点极限…… ","date":"2019-05-14","objectID":"/codeforces-1154f-round-552-div3-shovels-shop/:0:0","tags":["Codeforces"],"title":"Codeforces 1154F(Round 552 Div3) - Shovels Shop","uri":"/codeforces-1154f-round-552-div3-shovels-shop/"}]